# Finding-Donors-For-CharityML

Machine Learning Nanodegree Project Udacity

## Introduction
This repo contains all my work for Project 1 of Udacity's Machine Learning Basic Nanodegree Program. 
In this project, I applied supervised learning techniques and an analytical mind on data collected for 
the U.S. census to help CharityML (a fictitious charity organization) identify people most likely to 
donate to their cause. I first explored the data to learn how the census data is recorded. 
Next, I applied a series of transformations and preprocessing techniques to manipulate the data into a workable format. 
Then I evaluated several supervised learners of my choice on the data, and considered which is best suited for the solution. 
Afterwards, I optimized the model I had selected and presented it as my solution to CharityML. 
Finally, I explored the chosen model and its predictions under the hood, to see just how well 
it’s performing when considering the data it’s given. predicted selling price to the statistics.

## Software and Libraries
This project uses the following software and Python libraries:
NumPy, pandas, scikit-learn (v0.17), Matplotlib

Code Template  is provided in the finding_donors.ipynb notebook file. 
You will also be required to use the included visuals.py Python file and the census.csv dataset file to complete your work. 
While some code has already been implemented to get you started, you will need to implement additional functionality when 
requested to successfully complete the project. Note that the code included in visuals.py is meant to be used out-of-the-box 
and not intended for students to manipulate. If you are interested in how the visualizations are created in the notebook, 
please feel free to explore this Python file.

## Highlights
This project is designed to get you acquainted with the many supervised learning algorithms available in sklearn, 
and to also provide for a method of evaluating just how each model works and performs on a certain type of data. 
It is important in machine learning to understand exactly when and where a certain algorithm should be used, 
and when one should be avoided.
